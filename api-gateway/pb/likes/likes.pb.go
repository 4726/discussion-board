// Code generated by protoc-gen-go. DO NOT EDIT.
// source: likes.proto

package likes

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type IDUserID struct {
	Id                   *uint64  `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	UserId               *uint64  `protobuf:"varint,2,req,name=user_id,json=userId" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDUserID) Reset()         { *m = IDUserID{} }
func (m *IDUserID) String() string { return proto.CompactTextString(m) }
func (*IDUserID) ProtoMessage()    {}
func (*IDUserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{0}
}

func (m *IDUserID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDUserID.Unmarshal(m, b)
}
func (m *IDUserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDUserID.Marshal(b, m, deterministic)
}
func (m *IDUserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDUserID.Merge(m, src)
}
func (m *IDUserID) XXX_Size() int {
	return xxx_messageInfo_IDUserID.Size(m)
}
func (m *IDUserID) XXX_DiscardUnknown() {
	xxx_messageInfo_IDUserID.DiscardUnknown(m)
}

var xxx_messageInfo_IDUserID proto.InternalMessageInfo

func (m *IDUserID) GetId() uint64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *IDUserID) GetUserId() uint64 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

type Total struct {
	Total                *uint64  `protobuf:"varint,1,req,name=total" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Total) Reset()         { *m = Total{} }
func (m *Total) String() string { return proto.CompactTextString(m) }
func (*Total) ProtoMessage()    {}
func (*Total) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{1}
}

func (m *Total) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Total.Unmarshal(m, b)
}
func (m *Total) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Total.Marshal(b, m, deterministic)
}
func (m *Total) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Total.Merge(m, src)
}
func (m *Total) XXX_Size() int {
	return xxx_messageInfo_Total.Size(m)
}
func (m *Total) XXX_DiscardUnknown() {
	xxx_messageInfo_Total.DiscardUnknown(m)
}

var xxx_messageInfo_Total proto.InternalMessageInfo

func (m *Total) GetTotal() uint64 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

type IDs struct {
	Id                   []uint64 `protobuf:"varint,1,rep,packed,name=id" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDs) Reset()         { *m = IDs{} }
func (m *IDs) String() string { return proto.CompactTextString(m) }
func (*IDs) ProtoMessage()    {}
func (*IDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{2}
}

func (m *IDs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDs.Unmarshal(m, b)
}
func (m *IDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDs.Marshal(b, m, deterministic)
}
func (m *IDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDs.Merge(m, src)
}
func (m *IDs) XXX_Size() int {
	return xxx_messageInfo_IDs.Size(m)
}
func (m *IDs) XXX_DiscardUnknown() {
	xxx_messageInfo_IDs.DiscardUnknown(m)
}

var xxx_messageInfo_IDs proto.InternalMessageInfo

func (m *IDs) GetId() []uint64 {
	if m != nil {
		return m.Id
	}
	return nil
}

type TotalLikes struct {
	IdLikes              []*TotalLikes_IDLikes `protobuf:"bytes,1,rep,name=id_likes,json=idLikes" json:"id_likes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TotalLikes) Reset()         { *m = TotalLikes{} }
func (m *TotalLikes) String() string { return proto.CompactTextString(m) }
func (*TotalLikes) ProtoMessage()    {}
func (*TotalLikes) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{3}
}

func (m *TotalLikes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TotalLikes.Unmarshal(m, b)
}
func (m *TotalLikes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TotalLikes.Marshal(b, m, deterministic)
}
func (m *TotalLikes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalLikes.Merge(m, src)
}
func (m *TotalLikes) XXX_Size() int {
	return xxx_messageInfo_TotalLikes.Size(m)
}
func (m *TotalLikes) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalLikes.DiscardUnknown(m)
}

var xxx_messageInfo_TotalLikes proto.InternalMessageInfo

func (m *TotalLikes) GetIdLikes() []*TotalLikes_IDLikes {
	if m != nil {
		return m.IdLikes
	}
	return nil
}

type TotalLikes_IDLikes struct {
	Id                   *uint64  `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	Total                *uint64  `protobuf:"varint,2,req,name=total" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TotalLikes_IDLikes) Reset()         { *m = TotalLikes_IDLikes{} }
func (m *TotalLikes_IDLikes) String() string { return proto.CompactTextString(m) }
func (*TotalLikes_IDLikes) ProtoMessage()    {}
func (*TotalLikes_IDLikes) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{3, 0}
}

func (m *TotalLikes_IDLikes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TotalLikes_IDLikes.Unmarshal(m, b)
}
func (m *TotalLikes_IDLikes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TotalLikes_IDLikes.Marshal(b, m, deterministic)
}
func (m *TotalLikes_IDLikes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalLikes_IDLikes.Merge(m, src)
}
func (m *TotalLikes_IDLikes) XXX_Size() int {
	return xxx_messageInfo_TotalLikes_IDLikes.Size(m)
}
func (m *TotalLikes_IDLikes) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalLikes_IDLikes.DiscardUnknown(m)
}

var xxx_messageInfo_TotalLikes_IDLikes proto.InternalMessageInfo

func (m *TotalLikes_IDLikes) GetId() uint64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *TotalLikes_IDLikes) GetTotal() uint64 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

type IDsUserID struct {
	Id                   []uint64 `protobuf:"varint,1,rep,name=id" json:"id,omitempty"`
	UserId               *uint64  `protobuf:"varint,2,req,name=user_id,json=userId" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDsUserID) Reset()         { *m = IDsUserID{} }
func (m *IDsUserID) String() string { return proto.CompactTextString(m) }
func (*IDsUserID) ProtoMessage()    {}
func (*IDsUserID) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{4}
}

func (m *IDsUserID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDsUserID.Unmarshal(m, b)
}
func (m *IDsUserID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDsUserID.Marshal(b, m, deterministic)
}
func (m *IDsUserID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDsUserID.Merge(m, src)
}
func (m *IDsUserID) XXX_Size() int {
	return xxx_messageInfo_IDsUserID.Size(m)
}
func (m *IDsUserID) XXX_DiscardUnknown() {
	xxx_messageInfo_IDsUserID.DiscardUnknown(m)
}

var xxx_messageInfo_IDsUserID proto.InternalMessageInfo

func (m *IDsUserID) GetId() []uint64 {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *IDsUserID) GetUserId() uint64 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

type HaveLikes struct {
	HaveLikes            []*HaveLikes_HaveLike `protobuf:"bytes,1,rep,name=have_likes,json=haveLikes" json:"have_likes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *HaveLikes) Reset()         { *m = HaveLikes{} }
func (m *HaveLikes) String() string { return proto.CompactTextString(m) }
func (*HaveLikes) ProtoMessage()    {}
func (*HaveLikes) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{5}
}

func (m *HaveLikes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HaveLikes.Unmarshal(m, b)
}
func (m *HaveLikes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HaveLikes.Marshal(b, m, deterministic)
}
func (m *HaveLikes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HaveLikes.Merge(m, src)
}
func (m *HaveLikes) XXX_Size() int {
	return xxx_messageInfo_HaveLikes.Size(m)
}
func (m *HaveLikes) XXX_DiscardUnknown() {
	xxx_messageInfo_HaveLikes.DiscardUnknown(m)
}

var xxx_messageInfo_HaveLikes proto.InternalMessageInfo

func (m *HaveLikes) GetHaveLikes() []*HaveLikes_HaveLike {
	if m != nil {
		return m.HaveLikes
	}
	return nil
}

type HaveLikes_HaveLike struct {
	Id                   *uint64  `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	HasLike              *bool    `protobuf:"varint,2,req,name=has_like,json=hasLike" json:"has_like,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HaveLikes_HaveLike) Reset()         { *m = HaveLikes_HaveLike{} }
func (m *HaveLikes_HaveLike) String() string { return proto.CompactTextString(m) }
func (*HaveLikes_HaveLike) ProtoMessage()    {}
func (*HaveLikes_HaveLike) Descriptor() ([]byte, []int) {
	return fileDescriptor_cff81f36f81c8d8e, []int{5, 0}
}

func (m *HaveLikes_HaveLike) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HaveLikes_HaveLike.Unmarshal(m, b)
}
func (m *HaveLikes_HaveLike) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HaveLikes_HaveLike.Marshal(b, m, deterministic)
}
func (m *HaveLikes_HaveLike) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HaveLikes_HaveLike.Merge(m, src)
}
func (m *HaveLikes_HaveLike) XXX_Size() int {
	return xxx_messageInfo_HaveLikes_HaveLike.Size(m)
}
func (m *HaveLikes_HaveLike) XXX_DiscardUnknown() {
	xxx_messageInfo_HaveLikes_HaveLike.DiscardUnknown(m)
}

var xxx_messageInfo_HaveLikes_HaveLike proto.InternalMessageInfo

func (m *HaveLikes_HaveLike) GetId() uint64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *HaveLikes_HaveLike) GetHasLike() bool {
	if m != nil && m.HasLike != nil {
		return *m.HasLike
	}
	return false
}

func init() {
	proto.RegisterType((*IDUserID)(nil), "IDUserID")
	proto.RegisterType((*Total)(nil), "Total")
	proto.RegisterType((*IDs)(nil), "IDs")
	proto.RegisterType((*TotalLikes)(nil), "TotalLikes")
	proto.RegisterType((*TotalLikes_IDLikes)(nil), "TotalLikes.IDLikes")
	proto.RegisterType((*IDsUserID)(nil), "IDsUserID")
	proto.RegisterType((*HaveLikes)(nil), "HaveLikes")
	proto.RegisterType((*HaveLikes_HaveLike)(nil), "HaveLikes.HaveLike")
}

func init() { proto.RegisterFile("likes.proto", fileDescriptor_cff81f36f81c8d8e) }

var fileDescriptor_cff81f36f81c8d8e = []byte{
	// 341 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x91, 0xef, 0x4a, 0xf3, 0x30,
	0x14, 0xc6, 0xb7, 0xec, 0x4f, 0xdb, 0xa7, 0xef, 0x5e, 0x47, 0x14, 0xdc, 0x0a, 0xa2, 0x46, 0x91,
	0x09, 0x12, 0x61, 0xea, 0x0d, 0x68, 0x61, 0x06, 0xfc, 0x20, 0xc5, 0x7d, 0x1e, 0x85, 0x06, 0x5a,
	0xdc, 0x56, 0x59, 0xea, 0x6e, 0xce, 0x9b, 0x93, 0x24, 0x5d, 0x37, 0x36, 0x9c, 0x7e, 0xca, 0xc9,
	0xc9, 0x93, 0xe7, 0xfc, 0xce, 0x39, 0xf0, 0xa7, 0xd9, 0xbb, 0x54, 0xfc, 0x63, 0x91, 0x17, 0x39,
	0xbb, 0x83, 0x2b, 0xc2, 0xb1, 0x92, 0x0b, 0x11, 0xd2, 0xff, 0x20, 0x59, 0xd2, 0xab, 0x9f, 0x91,
	0x41, 0x33, 0x22, 0x59, 0x42, 0x8f, 0xe1, 0x7c, 0x2a, 0xb9, 0x98, 0x64, 0x49, 0x8f, 0x98, 0x64,
	0x5b, 0x5f, 0x45, 0xc2, 0x4e, 0xd0, 0x7a, 0xcb, 0x8b, 0x78, 0x4a, 0x8f, 0xd0, 0x2a, 0x74, 0x50,
	0x7e, 0xb2, 0x17, 0xd6, 0x47, 0x43, 0x84, 0x8a, 0xd2, 0xd2, 0xae, 0x31, 0x68, 0x3e, 0x92, 0x6e,
	0x5d, 0x5b, 0xb2, 0x19, 0x60, 0x7e, 0xbe, 0x68, 0x04, 0xca, 0xe1, 0x66, 0xc9, 0xc4, 0xe0, 0x18,
	0x9d, 0x3f, 0x3c, 0xe4, 0xeb, 0x67, 0x2e, 0x42, 0x73, 0x46, 0x4e, 0x96, 0x98, 0x20, 0xb8, 0x85,
	0x53, 0xe6, 0x76, 0x58, 0x2b, 0x12, 0xb2, 0x49, 0x72, 0x0f, 0x4f, 0x84, 0x6a, 0xab, 0xbd, 0xc6,
	0x6f, 0xed, 0x2d, 0xe1, 0x3d, 0xc7, 0x4b, 0x69, 0x0b, 0x0d, 0x81, 0x34, 0x5e, 0xca, 0x2d, 0xca,
	0xea, 0xbd, 0x8a, 0x22, 0x2f, 0x5d, 0xe5, 0x82, 0x07, 0xb8, 0xab, 0xf4, 0x0e, 0x68, 0x1f, 0x6e,
	0x1a, 0x2b, 0x63, 0x67, 0xca, 0xba, 0x91, 0x93, 0xc6, 0x4a, 0x4b, 0x87, 0x5f, 0x04, 0x2d, 0x5b,
	0xf4, 0x14, 0xae, 0x0e, 0x5e, 0x73, 0x55, 0x50, 0x8f, 0xaf, 0x16, 0x14, 0xb4, 0xed, 0x74, 0x58,
	0x8d, 0x9e, 0x03, 0xe3, 0xf9, 0x74, 0xaf, 0x84, 0xc1, 0xd7, 0x1e, 0x4f, 0xf9, 0x6c, 0x26, 0xe7,
	0x3f, 0x68, 0x2e, 0xd1, 0xb1, 0x36, 0x7b, 0x55, 0x17, 0xf8, 0x37, 0x92, 0x85, 0xae, 0x64, 0xe9,
	0x9a, 0x5c, 0x84, 0x2a, 0xf0, 0x37, 0x56, 0xc5, 0x6a, 0xf4, 0x0a, 0x07, 0x23, 0x59, 0x94, 0x3e,
	0x7b, 0x74, 0xd7, 0xe8, 0x68, 0x27, 0x55, 0x0d, 0x08, 0xbc, 0x5a, 0x51, 0x80, 0xf5, 0x60, 0x59,
	0x8d, 0xde, 0xa0, 0x5b, 0xfa, 0xfd, 0x41, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x35, 0xb7, 0xf4,
	0x2e, 0xd7, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LikesClient is the client API for Likes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LikesClient interface {
	LikePost(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error)
	UnlikePost(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error)
	LikeComment(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error)
	UnlikeComment(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error)
	GetPostLikes(ctx context.Context, in *IDs, opts ...grpc.CallOption) (*TotalLikes, error)
	GetCommentLikes(ctx context.Context, in *IDs, opts ...grpc.CallOption) (*TotalLikes, error)
	PostsHaveLike(ctx context.Context, in *IDsUserID, opts ...grpc.CallOption) (*HaveLikes, error)
	CommentsHaveLike(ctx context.Context, in *IDsUserID, opts ...grpc.CallOption) (*HaveLikes, error)
}

type likesClient struct {
	cc *grpc.ClientConn
}

func NewLikesClient(cc *grpc.ClientConn) LikesClient {
	return &likesClient{cc}
}

func (c *likesClient) LikePost(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error) {
	out := new(Total)
	err := c.cc.Invoke(ctx, "/Likes/LikePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) UnlikePost(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error) {
	out := new(Total)
	err := c.cc.Invoke(ctx, "/Likes/UnlikePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) LikeComment(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error) {
	out := new(Total)
	err := c.cc.Invoke(ctx, "/Likes/LikeComment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) UnlikeComment(ctx context.Context, in *IDUserID, opts ...grpc.CallOption) (*Total, error) {
	out := new(Total)
	err := c.cc.Invoke(ctx, "/Likes/UnlikeComment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) GetPostLikes(ctx context.Context, in *IDs, opts ...grpc.CallOption) (*TotalLikes, error) {
	out := new(TotalLikes)
	err := c.cc.Invoke(ctx, "/Likes/GetPostLikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) GetCommentLikes(ctx context.Context, in *IDs, opts ...grpc.CallOption) (*TotalLikes, error) {
	out := new(TotalLikes)
	err := c.cc.Invoke(ctx, "/Likes/GetCommentLikes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) PostsHaveLike(ctx context.Context, in *IDsUserID, opts ...grpc.CallOption) (*HaveLikes, error) {
	out := new(HaveLikes)
	err := c.cc.Invoke(ctx, "/Likes/PostsHaveLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likesClient) CommentsHaveLike(ctx context.Context, in *IDsUserID, opts ...grpc.CallOption) (*HaveLikes, error) {
	out := new(HaveLikes)
	err := c.cc.Invoke(ctx, "/Likes/CommentsHaveLike", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LikesServer is the server API for Likes service.
type LikesServer interface {
	LikePost(context.Context, *IDUserID) (*Total, error)
	UnlikePost(context.Context, *IDUserID) (*Total, error)
	LikeComment(context.Context, *IDUserID) (*Total, error)
	UnlikeComment(context.Context, *IDUserID) (*Total, error)
	GetPostLikes(context.Context, *IDs) (*TotalLikes, error)
	GetCommentLikes(context.Context, *IDs) (*TotalLikes, error)
	PostsHaveLike(context.Context, *IDsUserID) (*HaveLikes, error)
	CommentsHaveLike(context.Context, *IDsUserID) (*HaveLikes, error)
}

// UnimplementedLikesServer can be embedded to have forward compatible implementations.
type UnimplementedLikesServer struct {
}

func (*UnimplementedLikesServer) LikePost(ctx context.Context, req *IDUserID) (*Total, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LikePost not implemented")
}
func (*UnimplementedLikesServer) UnlikePost(ctx context.Context, req *IDUserID) (*Total, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlikePost not implemented")
}
func (*UnimplementedLikesServer) LikeComment(ctx context.Context, req *IDUserID) (*Total, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LikeComment not implemented")
}
func (*UnimplementedLikesServer) UnlikeComment(ctx context.Context, req *IDUserID) (*Total, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlikeComment not implemented")
}
func (*UnimplementedLikesServer) GetPostLikes(ctx context.Context, req *IDs) (*TotalLikes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPostLikes not implemented")
}
func (*UnimplementedLikesServer) GetCommentLikes(ctx context.Context, req *IDs) (*TotalLikes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommentLikes not implemented")
}
func (*UnimplementedLikesServer) PostsHaveLike(ctx context.Context, req *IDsUserID) (*HaveLikes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostsHaveLike not implemented")
}
func (*UnimplementedLikesServer) CommentsHaveLike(ctx context.Context, req *IDsUserID) (*HaveLikes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommentsHaveLike not implemented")
}

func RegisterLikesServer(s *grpc.Server, srv LikesServer) {
	s.RegisterService(&_Likes_serviceDesc, srv)
}

func _Likes_LikePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).LikePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/LikePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).LikePost(ctx, req.(*IDUserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_UnlikePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).UnlikePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/UnlikePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).UnlikePost(ctx, req.(*IDUserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_LikeComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).LikeComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/LikeComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).LikeComment(ctx, req.(*IDUserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_UnlikeComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).UnlikeComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/UnlikeComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).UnlikeComment(ctx, req.(*IDUserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_GetPostLikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).GetPostLikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/GetPostLikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).GetPostLikes(ctx, req.(*IDs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_GetCommentLikes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).GetCommentLikes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/GetCommentLikes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).GetCommentLikes(ctx, req.(*IDs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_PostsHaveLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).PostsHaveLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/PostsHaveLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).PostsHaveLike(ctx, req.(*IDsUserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Likes_CommentsHaveLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsUserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikesServer).CommentsHaveLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Likes/CommentsHaveLike",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikesServer).CommentsHaveLike(ctx, req.(*IDsUserID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Likes_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Likes",
	HandlerType: (*LikesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LikePost",
			Handler:    _Likes_LikePost_Handler,
		},
		{
			MethodName: "UnlikePost",
			Handler:    _Likes_UnlikePost_Handler,
		},
		{
			MethodName: "LikeComment",
			Handler:    _Likes_LikeComment_Handler,
		},
		{
			MethodName: "UnlikeComment",
			Handler:    _Likes_UnlikeComment_Handler,
		},
		{
			MethodName: "GetPostLikes",
			Handler:    _Likes_GetPostLikes_Handler,
		},
		{
			MethodName: "GetCommentLikes",
			Handler:    _Likes_GetCommentLikes_Handler,
		},
		{
			MethodName: "PostsHaveLike",
			Handler:    _Likes_PostsHaveLike_Handler,
		},
		{
			MethodName: "CommentsHaveLike",
			Handler:    _Likes_CommentsHaveLike_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "likes.proto",
}
